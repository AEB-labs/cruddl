"A delivery"
type Delivery @rootEntity @roles(readWrite: ["allusers"]) {
    deliveryNumber: String @key
    "The list of serial numbers associated with this delivery"
    serialNumbers: [String]
    "The address of the delivery's consignee"
    consignee: Address
    contentInfo: [Translation]
    dgInfo: DangerousGoodsInfo
    items: [DeliveryItem]
    "The handling units the items of this delivery are packaged in"
    handlingUnits: [HandlingUnit] @relation
    destinationCountry: Country @reference
    shippedAt: DateTime

    totalValue: String @roles(readWrite: ["accounting"])
    forwarder: Forwarder @relation

    destination: Address @defaultValue(value: {street: "Hauptstra√üe", city: "Stuttgart", zipCode: "70xxx", country: "DE"})
    defaultValueString: String @defaultValue(value: "foo")
    defaultValueString2: String @defaultValue(value: "bar")
    defaultValueInt: Int @defaultValue(value: 42)
    defaultValueTrue: Boolean @defaultValue(value: true)
    defaultValueFalse: Boolean @defaultValue(value: false)
    defaultValueFloat: Float @defaultValue(value: 3.14)
    defaultValueEnum: Foobarit @defaultValue(value: Bar)

    dynamicData: JSON
}

type DeliveryItem @childEntity {
    itemNumber: String
}

type Forwarder @rootEntity @roles(readWrite: ["logistics"]) {
    name: String @key
    deliveries: [Delivery] @relation(inverseOf:"forwarder")
}

# this can cause problems in schema generation because some input types might be empty
type OnlyRelations @rootEntity  @roles(readWrite: ["allusers"]) {
    deliveries: [Delivery] @relation
}

enum Foobarit {
    Foo
    Bar
    Baz
}
